#!/usr/bin/env sh
set -e

if [ $# -ne 2 ]; then
    echo "Usage: $(basename $0) <rev> <main-branch>"
    exit
else
    COMMIT="$1"
    BRANCH="${2:-HEAD}"  # https://www.gnu.org/software/bash/manual/bash.html#Shell-Parameter-Expansion
fi

if ! git rev-parse --quiet --verify $COMMIT &>/dev/null; then
    echo "'$COMMIT' does not exist"
    exit
elif ! git rev-parse --quiet --verify $BRANCH &>/dev/null; then
    echo "'$BRANCH' does not exist"
    exit
fi

# create two lists, one of all merges to mainline, second is all decendants of the commit we want to find it's merge to mainline.
# then, by comparing, sorting and removing duplicates, we can find the first commit
# (
#     git rev-list --ancestry-path $COMMIT..$BRANCH | cat -n;
#     git rev-list --first-parent $COMMIT..$BRANCH | cat -n;
# ) |
#     sort -k2 -s |     # stable sort by hash
#     uniq -f1 -d |     # leave only commits that
#     sort -n |         # sort by ancestory again (we have the numbering from cat -n)
#     tail -1 | cut -f2 # take the first decendent merge commit

mkfifo pipe1 pipe2

git rev-list --ancestry-path --merges $COMMIT..$BRANCH > pipe1 &
git rev-list --first-parent --merges $COMMIT..$BRANCH  > pipe2 & # --merges is redundant with --first-parent
comm -12 pipe1 pipe2 | tail -1

rm pipe1 pipe2

# in bash and zsh:
# comm -12 <(printf "%s" "$decendants") <(printf "%s" "$mainline") | tail -1
